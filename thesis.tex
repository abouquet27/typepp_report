%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% EPFL report package, main thesis file
% Goal: provide formatting for theses and project reports
% Author: Mathias Payer <mathias.payer@epfl.ch>
%
% To avoid any implication, this template is released into the
% public domain / CC0, whatever is most convenient for the author
% using this template.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper,11pt,oneside]{report}
% Options: MScThesis, BScThesis, MScProject, BScProject
\usepackage[MScThesis,lablogo]{EPFLreport}
\usepackage{xspace}

\title{Building a robust test suite of type confusion vulnerabilities}
\author{Adrien Bouquet}
\supervisor{Nicolas Badoux}
\adviser{Prof. Dr. sc. ETH Mathias Payer}

\expert{The External Reviewer}

\newcommand{\sysname}{FooSystem\xspace}
\newcommand{\todobox}[3]{%
       \colorbox{#1}{\textcolor{white}{\sffamily\bfseries\scriptsize #2}}%
       ~\textcolor{#1}{#3} %
       \textcolor{#1}{$\triangleleft$}%
}
\newcommand{\nb}[1]{\todobox{violet}{NB}{#1}}
\newcommand{\adrbqt}[1]{\todobox{red}{TODO}{#1}}

\begin{document}
\maketitle
\makededication
\makeacks

\begin{abstract}

The abstract serves as an executive summary of your project.
Your abstract should cover at least the following topics, 1-2 sentences for
each: what area you are in, the problem you focus on, why existing work is
insufficient, what the high-level intuition of your work is, maybe a neat
design or implementation decision, and key results of your evaluation.

My project: 
Explain Type confusion, and why they are a problem i.e memory attacks, safety, more control over types
compare two solutions to type confusion.
aim of the paper i.e., creating a general benchmark for type confusion and explain the results


\end{abstract}

\maketoc

%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
%%%%%%%%%%%%%%%%%%%%%%

The introduction is a longer writeup that gently eases the reader into your
thesis~\cite{dinesh20oakland}. Use the first paragraph to discuss the setting.
In the second paragraph you can introduce the main challenge that you see.
The third paragraph lists why related work is insufficient.
The fourth and fifth paragraphs discuss your approach and why it is needed.
The sixth paragraph will introduce your thesis statement. Think how you can
distill the essence of your thesis into a single sentence.
The seventh paragraph will highlight some of your results
The eights paragraph discusses your core contribution.

My project: 
1. Explain Type confusion, Hextype solution and Typepp solution
2. Measure Typepp solution by assessing tests and compare it to Hextype
3. Explain the aim of the paper, i.e. general benchmark for type confusion and how he achieves it

%%%%%%%%%%%%%%%%%%%%
\chapter{Background}
%%%%%%%%%%%%%%%%%%%%

The background section introduces the necessary background to understand your
work. This is not necessarily related work but technologies and dependencies
that must be resolved to understand your design and implementation.

This section is usually 3-5 pages.

My project:
1. Explain in more detail and with examples Type confusion, C++ inheritance and casting
2. Hextype and Typepp paradigm and how they handle type confusion

C++ is a general purpose programming language widely-used in a lot of domain such as Operating systems, 
or Machine Learning \nb{why uppercase}. While keeping the base of systems programming language C, C++ was developed with the aim of 
implementing new features, one of them being Object-Oriented Programming (OOP). In the following, we will introduce the key 
concept of OOP, and how it is implemented in C++. 

\subsection{Object-Oriented Programming, Class Hierarchies and Inheritance}
\adrbqt{Is talking more about Polymporphism worth it?}\nb{yes}
Object-Oriented Programming is about creating objects which are instances of classes that contain both data and functions. This paradigm provides
data abstraction, faster execution and code reusability. 

\adrbqt{Add an example of base-child relationship, Maybe it's better do to an example with a type confusion within}.

Classes are organized in hierarchies, generally with one base class and one derived class, and can inherit attributes and methods from other classes which they
they can use or override. \nb{add mention of where you find this in your example}A derived class can have multiple base classes and thus possesses all the methods and attributes from its base classes. 
Furthermore, a derived class is a subtype of its base class, meaning that a derived class can be used in place of its base class. This concept which is called 
Polymporphism, is remarkably practical but leads to some issues. For instance, when a base class has two derived classes that are not directly related to each other, 
it is possible to cast a pointer from one derived class to another in type casting by the base class.
This is called type confusion and can lead to memory corruption and security vulnerabilities. \nb{tc are much broader. I would introduce them before OOP}

\adrbqt{}
\subsection{Type Casting}
Typecasting is the operation of casting a pointer from a type to another. C++ provides four casting operators: static\_cast, dynamic\_cast, 
const\_cast and reinterpret\_cast \nb{also use texttt}.
\adrbqt{Add an example of type casting}

\texttt{\textbf{const\_cast}<target-type>(expression)} revokes the constness or volatileness of an object. Due to the operator's behaviour, it does not impact type hierarchies and 
thus does not lead to type confusion. Nevertheless, there are some issues with const\_cast, which won't be discussed in this paper, since not relevant to the subject. \nb{be more concise}

\texttt{\textbf{static\_cast}<target-type>(expression)} cast an expression to a specified type and checks only \nb{reptitive use of word check} compile-time without any runtime check. Therefore, this reduces cast verification to checking the types 
in the type hierarchy. It does not guarantee the types are compatible at runtime and places the onus back on programmers to ensure type correctness. Hence, it leads to a type confusion vulnerability when misused i.e.,
casting from the base class to a derived class or when casting a pointer to a void pointer.

\texttt{\textbf{reinterpret\_cast}<target-type>(expression)} similarly to static\_cast, it casts an expression to a specified type by reinterpreting the underlying bit pattern but with the difference 
that it does not check neither at compile time nor at runtime. Hence, it can potentially cast two incompatible types and lead to type confusion. 
It is also the programmer's responsibility to ensure the correctness of the target-type and the type of expression.

\texttt{\textbf{dynamic\_cast}<target-type>(expression)} cast safely an expression to a specified type and checks at compile-time and at runtime, unlike \texttt{static_cast}, if the types are compatible. 
To achieve the runtime check, \texttt{dynamic\_cast} must leverage heavy-weight metadata, Run Time Type Information (RTTI). However, RTTI is only available when the class has at least one virtual function 
and thus is polymorphic, which constraint to use \texttt{dynamic\_cast} only on polymorphic classes. In addition, security checks at runtime are more expensive than only compile-time checks because of their 
nature and can lead to performance issues by introducing overhead. \nb{not really, not a performance issue anymore}

Finally, C-style typecasting exists in C++ due to backward compatibility between both languages but highly discouraged due for instance to its lack of clarity for programmers. 
Furthermore, the compiler translate C-style typecasting to (i) \texttt{const\_cast}, (ii) \texttt{static\_cast} and (iii) \texttt{reinterpret\_cast} in this preferred order which passes on the underlying types confusions.

\adrbqt{check ISO/IEC 14882:2020 https://www.iso.org/standard/79358.html}

\subsection{Type confusion, Hextype and Typepp solutions}

%%%%%%%%%%%%%%%%
\chapter{Design}
%%%%%%%%%%%%%%%%

Introduce and discuss the design decisions that you made during this project.
Highlight why individual decisions are important and/or necessary. Discuss
how the design fits together.

This section is usually 5-10 pages.

My project:
1. Explain test suite on initialization 
2. Explain why it is a good benchmark to measure the efficiency of the solution
3. Example of test cases


%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%

The implementation covers some of the implementation details of your project.
This is not intended to be a low level description of every line of code that
you wrote but covers the implementation aspects of the projects.

This section is usually 3-5 pages.

How are we going to implement the test suite according to what was previously defined? What are the challenges? 
How are we going to measure the results?


%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation}
%%%%%%%%%%%%%%%%%%%%

In the evaluation you convince the reader that your design works as intended.
Describe the evaluation setup, the designed experiments, and how the
experiments showcase the individual points you want to prove.

This section is usually 5-10 pages.

Evalutates the test suite, explain the results
Stats that could be useful for a single sanitizers:
- Correctness: Number of type confusion detected and classified as type confusion by the sanitizer while they were
- False positive: Number of type confusion detected and classified as type confusion by the sanitizer while they weren't ones
- False negative: Number of type confusion missed by the sanitizer i.e., classified as not type confusion but they were

- type confusion detected and well classified by both
- type confusion missed by one of the two
- type confusion missed by both

Give intuition on how to improve the current solutions

%%%%%%%%%%%%%%%%%%%%%%
\chapter{Related Work}
%%%%%%%%%%%%%%%%%%%%%%

The related work section covers closely related work. Here you can highlight
the related work, how it solved the problem, and why it solved a different
problem. Do not play down the importance of related work, all of these
systems have been published and evaluated! Say what is different and how
you overcome some of the weaknesses of related work by discussing the 
trade-offs. Stay positive!

This section is usually 3-5 pages.

Discuss other sanitizers, other solutions to type confusion,
which may implements other solutions or same solutions but differently.

If time allows, test other sanitizer




%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}
%%%%%%%%%%%%%%%%%%%%

In the conclusion you repeat the main result and finalize the discussion of
your project. Mention the core results and why as well as how your system
advances the status quo.

Concludes the project 
\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Bibliography}
\printbibliography

% Appendices are optional
% \appendix
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \chapter{How to make a transmogrifier}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% In case you ever need an (optional) appendix.
%
% You need the following items:
% \begin{itemize}
% \item A box
% \item Crayons
% \item A self-aware 5-year old
% \end{itemize}

\end{document}
