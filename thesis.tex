%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% EPFL report package, main thesis file
% Goal: provide formatting for theses and project reports
% Author: Mathias Payer <mathias.payer@epfl.ch>
%
% To avoid any implication, this template is released into the
% public domain / CC0, whatever is most convenient for the author
% using this template.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper,11pt,oneside]{report}
% Options: MScThesis, BScThesis, MScProject, BScProject
\usepackage[MScProject,lablogo]{EPFLreport}
\usepackage{xspace}
\usepackage{xcolor}
\usepackage[chapter]{minted}
\setminted{numbersep=3pt}
\setminted{fontsize=\footnotesize}
\usepackage{listings}

\title{Building a robust test suite of type confusion vulnerabilities}
\author{Adrien Bouquet}
\supervisor{Nicolas Badoux}
\adviser{Prof. Dr. sc. ETH Mathias Payer}

\expert{The External Reviewer}

\newcommand{\sysname}{FooSystem\xspace}
\newcommand{\todobox}[3]{%
       \colorbox{#1}{\textcolor{white}{\sffamily\bfseries\scriptsize #2}}%
       ~\textcolor{#1}{#3} %
       \textcolor{#1}{$\triangleleft$}%
}
\newcommand{\nb}[1]{\todobox{violet}{NB}{#1}}
\newcommand{\adrbqt}[1]{\todobox{red}{TODO}{#1}}

\begin{document}
\maketitle
\dedication{\textit{Program testing can be used to show the presence of bugs, but never to show their absence!}
\begin{flushright}
"Notes On Structured Programming" by Edsger W. Dijkstra, April 1970.
\end{flushright}
}
\makededication
\acknowledgments{
I would like to thank my supervisor, Nicolas Badoux, for his guidance and support throughout this project. 
Finally, I would like to thank my family and friends for their support
}
\makeacks



\begin{abstract}

The abstract serves as an executive summary of your project.
Your abstract should cover at least the following topics, 1-2 sentences for
each: what area you are in, the problem you focus on, why existing work is
insufficient, what the high-level intuition of your work is, maybe a neat
design or implementation decision, and key results of your evaluation.

My project: 
Explain Type confusion, and why they are a problem i.e memory attacks, safety, more control over types
compare two solutions to type confusion.
aim of the paper i.e., creating a general benchmark for type confusion and explain the results


\end{abstract}

\maketoc

%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
%%%%%%%%%%%%%%%%%%%%%%

The introduction is a longer writeup that gently eases the reader into your
thesis~\cite{dinesh20oakland}. Use the first paragraph to discuss the setting.
In the second paragraph you can introduce the main challenge that you see.
The third paragraph lists why related work is insufficient.
The fourth and fifth paragraphs discuss your approach and why it is needed.
The sixth paragraph will introduce your thesis statement. Think how you can
distill the essence of your thesis into a single sentence.
The seventh paragraph will highlight some of your results
The eights paragraph discusses your core contribution.

My project: 
1. Explain Type confusion, Hextype solution and type++ solution
2. Measure type++ solution by assessing tests and compare it to Hextype
3. Explain the aim of the paper, i.e. general benchmark for type confusion and how he achieves it

%%%%%%%%%%%%%%%%%%%%
\chapter{Background}
%%%%%%%%%%%%%%%%%%%%

The background section introduces the necessary background to understand your
work. This is not necessarily related work but technologies and dependencies
that must be resolved to understand your design and implementation.

This section is usually 3-5 pages.

My project:
0. Introduce C++, Type confusion
1. Explain in more detail and with examples, C++ inheritance and casting
2. Hextype and type++ paradigm and how they handle type confusion

C++ is a general purpose programming language widely-used in a lot of domain such as operating systems, 
or machine learning. Types are a core concept in C++ but are source of vulnerabilities. For instance, type confusion 
is a common security issue in C++, which occurs when the compiler misinterpret a pointer's type generally after a wrong typecasting and,
that can lead to memory corruption and security vulnerabilities. An adversary can then exploit this vulnerability to execute arbitrary code, heap corruption and hijack the control-flow.
Such an attack occured in the past in V8 in Google Chrome, where it allowed a remote attacker to potentially exploit
heap corruption via a crafted HTML page (CVE-2023-3079). Hence, it is crucial to detect wrong typecasting which induce type confusion. 
Theses wrong casts can occur when casting a pointer outside of a type hierarchy (\texttt{char*} to \texttt{void*} then casting to another type, see line \ref{code:unrelated_type_confusion} in Listing \autoref{lst:type_confusion}) 
and inside a type hierarchy with classes and object-oriented programming e.g., casting a pointer from a base class to a derived class. 
which can lead to memory corruption and security vulnerabilities. In this chapter, we will
expose the object-oriented programming, class hierarchies and inheritance in C++ \autoref{sec:cpp_oop}, 
and present the different type casting operators in C++ \autoref{sec:cpp_type_casting}. 
Finally, we will present the different solutions to type confusion and how they handle it \autoref{sec:cpp_solutions}.

\begin{listing}
       \begin{minted}[frame=single,linenos, breaklines, escapeinside=||]{C++}
#include <iostream>
#include <string>
#include <stdexcept>
using namespace std;

class Base{ public: string id = "Base";}; // Base class

class Dummy: public Base{ // Derived class 1
  string name = "Dummy"; // private attribute
public:
  void setMyNameAndId(string name, string id){ // unsafe function
    this->name = name; 
    this->id = id;
  }
};

class Password: public Base{ // Derived class 2
  string myPassWord = "123456"; // private attribute (it should be protected)
public:
  void setMyPassword(string oldPassword, string newPassword){ // function we want to bypass
    if(oldPassword == myPassWord){ // check if the old password is correct
      myPassWord = newPassword; // change the password
    } else {
    throw invalid_argument("Invalid password");  
    // throw an exception if the old password is incorrect
    }  
  }
};

class Unrelated{ // Unrelated class
  string id = "id";
  string name = "Unrelated";
public:
  void print() { cout << name << " " << id << endl; };
};

void doStuff(Base* base){
  // type confusion within the same class hierarchy
  Dummy* dummy = static_cast<Dummy*>(base); |\label{code:derived_type_confusion}|
  // change the password by exploiting the type confusion 
  dummy->setMyNameAndId("You've have been hacked","LOL");      
}

int main(){
  Password* password = new Password();   // change the password to "MyHardPassword"
  password->setMyPassword("123456","MyHardPassword"); |\label{code:password}|
  Base* base = password; // upcast 
  doStuff(base); |\label{code:polymorphism}| // type confusion within the same class hierarchy
  // type confusion outside the class hierarchy
  Unrelated* unrelated = (Unrelated*)reinterpret_cast<void*>(password); |\label{code:unrelated_type_confusion}|
  unrelated->print(); // print illegally the new password
  return 0;    
}
       \end{minted}
       \caption{Example of type confusion in C++ within the same class hierarchy}
       \label{lst:type_confusion}
\end{listing}

\section{Object-Oriented Programming, Class Hierarchies and Inheritance} \label{sec:cpp_oop}
Object-Oriented Programming (OOP) is about creating objects which are instances of classes that contain both data and functions. This paradigm provides
data abstraction, faster execution and code reusability. Classes are organized in hierarchies, generally with one base class and one derived class, and can inherit attributes and methods from other classes which they
they can use or override. In Listing \autoref{lst:type_confusion}, the classes \texttt{Password} and \texttt{Dummy} are derived from the base class \texttt{Base}, 
whereas the class \texttt{Unrelated} is unrelated to their class hierarchy.
A derived class can have multiple base classes and thus possesses all the methods and attributes from its base classes. 
Furthermore, a derived class is a subtype of its base class, meaning that a derived class can be used in place of its base class e.g., at line \ref{code:polymorphism}
a \texttt{Password} pointer is given instead of a \texttt{Base} pointer. This concept which is called 
polymorphism, is remarkably practical but leads to some issues. For instance, when a base class has two derived classes that are not directly related to each other, 
it is possible to cast a pointer from one derived class to another in type casting by the base class and induce type confusion, 
as at line \ref{code:derived_type_confusion}, where a \texttt{Password*} is cast to a \texttt{Dummy*} after being cast to a \texttt{Base*}. 

\section{Type Casting} \label{sec:cpp_type_casting}
Typecasting is the operation of casting a pointer from a type to another. C++ provides four casting operators: \texttt{static\_cast}, \texttt{dynamic\_cast}, 
\texttt{const\_cast} and \texttt{reinterpret\_cast}. 

\texttt{\textbf{const\_cast}<target-type>(expression)} revokes the constness or volatileness of an object. Due to the operator's behaviour, it does not impact type hierarchies and 
thus does not lead to type confusion altough there are some issues with const\_cast.

\texttt{\textbf{static\_cast}<target-type>(expression)} cast an expression to a specified type while check at compile-time but not at runtime. Therefore, this reduces cast verification to checking the types 
in the type hierarchy. It does not guarantee the types are compatible at runtime and places the onus back on programmers to ensure type correctness. Hence, it leads to a type confusion vulnerability when misused i.e.,
casting from the base class to a derived class or when casting a pointer to a void pointer.

\texttt{\textbf{reinterpret\_cast}<target-type>(expression)} similarly to static\_cast, it casts an expression to a specified type by reinterpreting the underlying bit pattern but with the difference 
that it does not check neither at compile time nor at runtime. Hence, it can potentially cast two incompatible types and lead to type confusion. 
It is also the programmer's responsibility to ensure the correctness of the target-type and the type of expression.

\texttt{\textbf{dynamic\_cast}<target-type>(expression)} cast safely an expression to a specified type and checks at compile-time and at runtime, unlike \texttt{static\_cast}, if the types are compatible. 
To achieve the runtime check, \texttt{dynamic\_cast} must leverage heavy-weight metadata, Run Time Type Information (RTTI). However, RTTI is only available when the class has at least one virtual function 
and thus is polymorphic, which constraint to use \texttt{dynamic\_cast} only on polymorphic classes.

Finally, C-style typecasting exists in C++ due to backward compatibility between both languages but highly discouraged due for instance to its lack of clarity for programmers. 
Furthermore, the compiler translate C-style typecasting to (i) \texttt{const\_cast}, (ii) \texttt{static\_cast} and (iii) \texttt{reinterpret\_cast} in this preferred order which passes on the underlying types confusions.

\section{Solutions, Hextype and type++} \label{sec:cpp_solutions}

As previously mentioned, type confusion vulnerabilities can lead to some memory corruption and security vulnerabilities which products such as Telegram (CVE-2021-31318, CVE-
2021-31317) or Google Chromium (CVE-2021-30627,CVE-2022-1096, CVE-2022-1134, CVE-2022-2295) are exposed to. Listing \autoref{lst:type_confusion} shows an example of a type confusion.
First, we define a base class \texttt{Base} and two derived classes \texttt{Dummy} and \texttt{Password} with their own attributes and methods. We set up the password to "MyHardPassword" (line \ref{code:password}) of a our class. 
The password pointer is cast to its base and passed to a function \texttt{doStuff} which cast it to a \texttt{Dummy*}. This a type confusion within the same class hierarchy. 
Then, the password pointer is cast to an unrelated class \texttt{Unrelated} and printed. This is a type confusion outside the class hierarchy.
Hence, it is a problem that require to be handled for developer and user safety. 
The compiler checks statically the correctness of each cast to ensure that the types are compatible but it does not guarantee the same correctness at runtime, 
because for instance an object of a derived class can be used in place of an object of a base class due to polymorphism and vice versa as in line \ref{code:polymorphism}. 
To detect type confusion at runtime, there exists two approaches: (i) relying on disjoint metadata, such as type table to keep track of each type of each object or trees for type hierarchy, and 
(ii) relying on existing metadata, such as Runtime Type Information (RTTI) and vtables. 
Generally, the first approach is more efficient because it covers more types but it introduces overhead and performance issues. The second is faster but less efficient due to its limitation to polymorphic classes and it caused some crash issue. 
In this paper, we will focus and compare on two solutions: Hextype and type++. 
Both solutions checks types correctness at runtime but they differ in their approach. Comparing them offers a perspective on the effectiveness of each approach, despite the age difference between the development of these two solutions.
Hextype is older and relies on disjoint metadata to achieve types correctness. 
Type++ is a recent solution and relies on existing metadata to achieve types correctness but unlike an approach based solely on existing metadata for polymorphism object,
it extends this by adding a vtable pointer to each object to enforce efficiency, cover more types and avoid crash issue. In the following, we will detail how Hextype and type++ work.

\subsection{Hextype}
What I want to talk about Hextype?
\begin{itemize}
       \item What is Hextype?
       \item How does it work?
       \item Its limitations (detect type confusion from cast inside the hierarchy)
\end{itemize}

HexType is a Clang/LLVM-based type confusion sanitizer used to detect type confusion vulnerabilities in C++ programs. 
It relies on disjoint metadata to keep track of each type of each object and to check types correctness at runtime.

\subsection{type++}

What I want to talk about type++?
\begin{itemize}
       \item What is type++?
       \item How does it work?
       \item Its limitations \adrbqt{To be discussed with Nicolas}
\end{itemize}


%%%%%%%%%%%%%%%%
\chapter{Design}
%%%%%%%%%%%%%%%%

Introduce and discuss the design decisions that you made during this project.
Highlight why individual decisions are important and/or necessary. Discuss
how the design fits together.

This section is usually 5-10 pages.

\adrbqt{Is adding a paragraph on particular case such as phantom cast, multiple inheritance, placement new or allocation a good idea ?}

\begin{itemize}
       \item Threat model and aim of the suite 
       \item Why testing initialization? How is it relevant?
       \item Why is it a good benchmark? How to measure the efficiency of the solution?

\end{itemize}

\section{Benchmarking Type Confusion}

Our threat model assumes that an adversary can exploit type confusion vulnerabilities to execute arbitrary code. 
We built a test suite with a multitude of cases to evaluate how a sanitizer or a C++ dialect can detect these types confusion and, 
a fortiori, try to prevent such adversaries from exploiting these vulnerabilities,
We particularly focus on the initialization, modifications and deletion of objects and pointers. At initialization step 
both methods act on values to keep track of their types, type++ by adding a vtable pointer to every object and Hextype by recording all necessary 
information in its disjoint metadata. Then we try modify the pointers by casting, modifying the object referenced to, 
or deleting a pointer and reusing it to observe if it correctly detects type confusion. The last examples is particularly interesting
for Hextype due to its nature. In fact, we want Hextype to replace the type of the object inside its type table when modifying 
the corresponding pointer. Theses aspects are known to be backpain points for Hextype. Furthermore, we want to test each solutions
on dynamic memory allocation styles such as \texttt{malloc} or \texttt{calloc}. 

We want to compare the results obtained from Hextype and type++, individually and between them. The benchmark quality resides 
in the diversity and coverage offered by most of the tests. In the following we will concentrate on C++11,
although there are more recent versions with more features dedicated to OOP. In addition, we mainly test the standard
C++11 without any external libraries or frameworks to simplify and evaluate the basis of the language itself. Later on,
it could be interesting to extends the test suite to more recent versions of C++ and to external libraries. 

%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%

The implementation covers some of the implementation details of your project.
This is not intended to be a low level description of every line of code that
you wrote but covers the implementation aspects of the projects.

This section is usually 3-5 pages.

How are we going to implement the test suite according to what was previously defined? What are the challenges? 
How are we going to measure the results?

\begin{itemize}
       \item How are we going to implement the test suite according to what was previously defined? 
       \item What were the challenges?
       \item How are we going to measure the results?
       \item Example of test cases
\end{itemize}


%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation}
%%%%%%%%%%%%%%%%%%%%

In the evaluation you convince the reader that your design works as intended.
Describe the evaluation setup, the designed experiments, and how the
experiments showcase the individual points you want to prove.

This section is usually 5-10 pages.

Evalutates the test suite, explain the results
Stats that could be useful for a single sanitizers:
\begin{itemize}
       \item Correctness: Number of type confusion detected and classified as type confusion by the sanitizer while they were
       \item False positive: Number of type confusion detected and classified as type confusion by the sanitizer while they weren't ones
       \item False negative: Number of type confusion missed by the sanitizer i.e., classified as not type confusion but they were

       \item type confusion detected and well classified by both
       \item type confusion missed by one of the two
       \item type confusion missed by both

       \item Constraint and limit of the test suite

\end{itemize}

Give intuition on how to improve the current solutions

%%%%%%%%%%%%%%%%%%%%%%
\chapter{Related Work}
%%%%%%%%%%%%%%%%%%%%%%

The related work section covers closely related work. Here you can highlight
the related work, how it solved the problem, and why it solved a different
problem. Do not play down the importance of related work, all of these
systems have been published and evaluated! Say what is different and how
you overcome some of the weaknesses of related work by discussing the 
trade-offs. Stay positive!

This section is usually 3-5 pages.

Discuss other sanitizers, other solutions to type confusion,
which may implements other solutions or same solutions but differently.

If time allows, test other sanitizer




%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}
%%%%%%%%%%%%%%%%%%%%

In the conclusion you repeat the main result and finalize the discussion of
your project. Mention the core results and why as well as how your system
advances the status quo.

Concludes the project 
\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Bibliography}
\printbibliography

% Appendices are optional
% \appendix
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \chapter{How to make a transmogrifier}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% In case you ever need an (optional) appendix.
%
% You need the following items:
% \begin{itemize}
% \item A box
% \item Crayons
% \item A self-aware 5-year old
% \end{itemize}

\end{document}
